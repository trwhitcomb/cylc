\section{Suite.rc Reference}
\label{SuiteRCReference}

\lstset{language=bash}

This appendix documents all legal entries in a suite.rc file. Most
suites will only need to explicitly configure a few of these items -
many of them have sensible default values, some may only be needed for
critical operational suites (e.g.\ secure passphrases), and some are
primarily used for cylc development. In general your suite.rc files
shouldn't be a lot more complicated than those of the cylc example
suites.

See also {\em Suite Definition - Suite.rc Overview}
(Section~\ref{SuiteRCFile}) for a descriptive overview of suite.rc
files.

\subsection{Top Level Items}

The only top level configuration items at present are the suite title
and description.

\subsubsection{title}

The suite title is displayed in the gcylc suite database window. It can
also be retrieved from a suite at run time with \lstinline=cylc show= 
(or use \lstinline=cylc get-config=).

\begin{myitemize}
\item {\em type:} string 
\item {\em default:} ``No title provided''
\end{myitemize}

\subsubsection{description}

The suite description can be retrieved by gcylc right-click menu. It 
can also be retrieved from a suite at run time with 
\lstinline=cylc show= (or use \lstinline=cylc get-config=).

\begin{myitemize}
\item {\em type:} string
\item {\em default:} ``No description provided''
\end{myitemize}

\subsection{[cylc]}

This section is for suite configuration that is not specifically
task-related.

\subsubsection[UTC mode]{ [cylc] $\rightarrow$ UTC mode}

Cylc runs off the suite host's system clock by default. This item allows
you to run the suite in UTC even if the system clock is set to local time.
Clock-triggered tasks will trigger when the current UTC time is equal to
their cycle time plus offset; other time values used, reported, or
logged by cylc will also be in UTC. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False 
\end{myitemize}

\subsubsection[simulation mode only]{ [cylc] $\rightarrow$ simulation mode only}

This prevents a suite from running in real mode - use for demo suites
created by copying real suites out of their normal operating environment.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[use secure passphrase]{ [cylc] $\rightarrow$ use secure passphrase}

Critical operational suites can be made to ignore commands unless the
originating user account has a special passphrase (the same one used 
by the suite owner at startup) with secure permissions (as for ssh keys)
in the file \lstinline=$HOME/.cylc/security/$CYLC_SUITE_REG_NAME=
(remotely hosted tasks also need the passphrase in their host accounts). 
The passphrase itself is never transferred across the network (a secure
MD5 checksum is). Note that cylc's normal owner-only suite access is
implemented by means of a simple username comparison, which could in
principle be subverted by a malicious user copying and modifying the 
cylc code base. Secure passphrases, on the other hand, should guarantee
suite security so long as your user accounts aren't breached. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}logging{]]} ]{[cylc] $\rightarrow$ [[logging]]}

This section configures cylc's logging functionality, which records
time-stamped events to a special log file. 

\paragraph[directory]{[cylc] $\rightarrow$ [[logging]] $\rightarrow$ directory}

The cylc log and its backups are stored in this directory. If you change
the directory make sure it remains suite-specific by using suite
identity environment variables in the path.

\begin{myitemize}
    \item {\em type:} string (directory path, may contain environment variables)
    \item {\em default:} \lstinline=$HOME/cylc-run/$CYLC_SUITE_REG_NAME/log/suite=
\end{myitemize}

\paragraph[roll over at start-up]{[cylc] $\rightarrow$ [[logging]] $\rightarrow$ roll over at start-up}

Suite logs roll over (start anew) automatically when they reach a
certain size - currently hardwired to 1MB in
\lstinline=$CYLC_DIR/lib/cylc/pimp_my_logger.py=. 
They can also be rolled automatically whenever a
suite is started or restarted.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\subsubsection[{[[}state dumps{]]}]{ [cylc] $\rightarrow$ [[state dumps]] }

 State dump files allow cylc to restart suites from previous states of
 operation. 

\paragraph[directory]{[cylc] $\rightarrow$ [[state dumps]] $\rightarrow$ directory}

 The rolling archive of suite state dump files, backups of the default 
 state dump, and any special pre-intervention state dumps, are stored
 under this directory.  If you change this directory make sure it
 remains suite-specific by using suite identity environment variables in
 the path.

\begin{myitemize}
    \item {\em type:} string (directory path, may contain environment variables)
    \item {\em default:} \lstinline=$HOME/cylc-run/$CYLC_SUITE_REG_NAME/state=
\end{myitemize}

\paragraph[number of backups]{[cylc] $\rightarrow$ [[state dumps]] $\rightarrow$ number of backups}

This is the length, in number of changes, of the automatic rolling
archive of state dump files that allows you to restart a suite from a
previous state.  Every time a task changes state cylc updates the state
dump and rolls previous states back one on the archive.  You'll probably
only ever need the latest (most recent) state dump, which is
automatically used in a restart, but any previous state still in the
archive can be used.  Additionally, special labeled state dumps are
written out prior to actioning any suite intervention - their filenames
are logged by cylc.

\begin{myitemize}
    \item {\em type:} integer ($\geq 1$)
    \item {\em default:} $10$
\end{myitemize}

\subsubsection[{[[}lockserver{]]}]{[cylc] $\rightarrow$ [[lockserver]]}

The cylc lockserver brokers suite and task locks on the network (these
are somewhat analagous to traditional local {\em lock files}). It
prevents multiple instances of a suite or task from being invoked 
at the same time (via scheduler instances or \lstinline=cylc submit=).
 
See \lstinline=cylc lockserver --help= for 
how to run the lockserver, and \lstinline=cylc lockclient --help= for 
occasional manual lock management requirements. 

\paragraph[enable]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ enable}

The lockserver is currently disabled by default. It is intended mainly for
operational use.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[simultaneous instances]{[cylc] $\rightarrow$ [[lockserver]] $\rightarrow$ simultaneous instances}

By default the lockserver prevents multiple simultaneous instances of a
suite from running even under different registered names. But allowing
this may be desirable if the I/O paths of every task in the suite are
dynamically configured to be suite specific (and similarly for the suite
state dump and logging directories, by using suite identity variables in
their directory paths). Note that {\em the lockserver cannot protect you
from running multiple distinct {\bf copies} of a suite simultaneously}. 

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsubsection[{[[}environment{]]} ]{[cylc] $\rightarrow$ [[environment]]}

Variables defined here are exported to the environment in which cylc
itself runs, for possible use by processes spawned directly by cylc 
(e.g.\ event hook scripts). {\em Note that these variables are only 
available to executing tasks if you happen to choose a local direct job
submission method - use task runtime environments for this purpose}.

\paragraph[\_\_VARIABLE\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_VARIABLE\_\_}

Replace \_\_VARIABLE\_\_ with an environment variable assignment and
repeat for as many local environment variables as you need. 
Values may contain local environment variables. General shell variable
expansion expressions will not be expanded (these are legal in 
task runtime environments, however).

\begin{myitemize}
    \item {\em type:} string (may contain local environment variables).
    \item {\em default:} (none)
    \item {\em examples:} 
        \begin{myitemize}
            \item \lstinline@FOO = $HOME/foo@
        \end{myitemize}
\end{myitemize}

\subsubsection[{[[}simulation mode{]]}]{[cylc] $\rightarrow$ [[simulation mode]] }

Items specific to running suites in simulation mode.

\paragraph[clock rate]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ clock rate}

This determines the speed at which the simulation mode clock runs, in 
real seconds per simulated hour. A value of 10, for example, means it
will take 10 real seconds to simulate one hour of operation.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, real seconds per simulated hour)
    \item {\em default:} $10$
\end{myitemize}

\paragraph[clock offset]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ clock offset}

The clock offset determines the initial time on the simulation clock, 
at suite startup, relative to the initial cycle time.  An offset of
$0$ simulates real time operation; greater offsets simulate catch up
from a delay and subsequent transition to real time operation.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours behind initial cycle time)
    \item {\em default:} $24$
\end{myitemize}

\paragraph[command scripting]{ [cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ command scripting}

The command scripting to execute for all tasks when running in simulation mode.
\begin{myitemize}
\item {\em type:} string (scripting valid in job submission shell;
    triple quote for multiple lines)
\item {\em default:} \lstinline=echo SIMULATION MODE $CYLC_TASK_ID; sleep 10; echo BYE=
\end{myitemize}

\paragraph[{[[[}job submission{]]]} ]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[job submission]]]} 

Configure job submission for simulation mode.

\subparagraph[method]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[job submission]]] $\rightarrow$ method } 

The job submission method to use for all tasks in simulation mode. Any 
available method can be used but the default is probably sufficient for simulation mode.

\begin{myitemize}
    \item {\em type:} string (a job submission method name - see Section~\ref{RuntimeJobSubMethods})
    \item {\em default:} \lstinline=background=
\end{myitemize}

\paragraph[{[[[}event hooks{]]]} ]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[event hooks]]]} 

Configure event hooks for simulation mode.

\subparagraph[enable]{[cylc] $\rightarrow$ [[simulation mode]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ enable } 

Currently event hooks are disabled by default in simulation mode. They
can be enabled in order to test automated alerts, for example, without
running the real suite tasks, but be aware that timeouts will be 
relative to the accelerated simulation mode clock which by default runs
very quickly.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\subsection{[scheduling]}

This section allows cylc to determine when tasks are ready to run.

\subsubsection[initial cycle time]{[scheduling] $\rightarrow$ initial cycle time}

At startup each cycling task (unless specifically excluded under
[special tasks]) will be inserted into the suite with this cycle time,
or with the closest subsequent valid cycle time for the task. Note that
whether or not {\em cold-start tasks}, specified under [special tasks],
are inserted, and in what state they are inserted, depends on the start
up method - cold, warm, or raw.  If this item is provided you can 
override it on the command line or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYYMMDDHH)
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[final cycle time]{[scheduling] $\rightarrow$ final cycle time}

Cycling tasks are held (i.e.\ not allowed to spawn a successor) once they
pass the final cycle time, if one is specified. Once all tasks have
achieved this state the suite will shut down. If this item is provided you 
can override it on the command line or in the gcylc suite start panel.

\begin{myitemize}
    \item {\em type:} integer (YYYYMMDDHH)
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[runahead limit]{[scheduling] $\rightarrow$ runahead limit}

A cycling task spawns a successor either when it starts running or, for
sequential tasks, when it finishes. If the successor's cycle time is
ahead of the oldest non-failed task by more than the runahead limit it 
will be put into special ``runahead held'' state until other tasks
catch up sufficiently. This prevents quick-running unconstrained tasks
in historical trials (i.e.\ sustained catch up operation) from running
off into the future and potentially swamping the system. In real time
operation the runahead limit is of little consequence because the suite
will be constrained by its clock-triggered tasks (the limit must be long
enough to cover the range of tasks present in the suite, however; a task
that only runs once per day, for instance, needs to spawn 24 hours
ahead).  Failed tasks, which are not automatically removed from a suite,
are ignored when computing the runahead limit (but tasks that can't run
because they depend on a failed task are not ignored). 
\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} $24$
\end{myitemize}

\subsubsection[{[[}special tasks{]]}]{[scheduling] $\rightarrow$ [[special tasks]]}

This section identifies any tasks with special behaviour. By default
(i.e.\ non ``special'' behaviour) tasks submit as soon as their
prerequisites are satisfied, and they spawn a successor at the next
valid cycle time for the task as soon as they enter the running
state\footnote{Spawning any
earlier than this brings no advantage in terms of functional
parallelism.}

\paragraph[clock-triggered]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ clock-triggered}

Clock-triggered tasks wait on a wall clock time specified as an offset
{\em in hours} relative to their own cycle time, in addition to any
dependence they have on other tasks. {\em Generally speaking, only tasks
that wait on external real time data need to be clock-triggered}.
\begin{myitemize}
    \item {\em type:} list of tasknames with offsets (hours, positive or negative)
    \item {\em default:} (none)
    \item {\em example:} \lstinline@clock-triggered = foo(1.5), bar(2.25)@
\end{myitemize}
{\em Clock-triggered tasks cannot be triggered manually prior to
their trigger time}. Workaround: just run the task alone 
with \lstinline=cylc submit= then set the in-suite task's state to
`succeeded' so that downstream tasks can trigger off it. 

\paragraph[start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ start-up}

Start-up tasks are one-off tasks that are only used when a suite is cold
started (i.e.\ starting up without assuming any previous cycle). They
can be used to clean out or prepare a suite workspace, for example,
before other tasks run. 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[cold-start]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ cold-start}

A cold-start task (or possibly a sequence of them) is used to satisfy
the dependence of an associated task with the same cycle time, on
outputs from a previous cycle - when those outputs are not available.
The primary use for this is to cold-start a warm-cycled forecast model
that normally depends on restart files (e.g.\ model background fields)
generated by its previous forecast, when there is no previous forecast.
This is required when cold-starting the suite, but cold-start tasks can
also be inserted into a running suite to restart a model that has had to
skip some cycles after running into problems (e.g.\ critical
inputs not available). Cold-start tasks can invoke real cold-start
processes, or they can just be dummy tasks that represent some external
process that has to be completed before the suite is started.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[sequential]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ sequential}

By default, a task spawns a successor as soon as it starts running, so
that successive instances of the same task can run in parallel if the
opportunity arises (i.e.\ if their prerequisites happen to be satisfied
before their predecessor has finished). {\em Sequential tasks}, however,
will not spawn a successor until they have finished successfully. This
should be used for (a) {\em tasks that cannot run in parallel with their
own previous instances} because they would somehow interfere with each
other (use cycle time in all I/O paths to avoid this); and (b) {\em Warm
cycled forecast models that write out restart files for multiple cycles
ahead} (exception: see ``explicit restart outputs''
below).\footnote{This is because you don't want Model(T) waiting around
to trigger off Model(T-12) if Model(T-6) has not finished yet. If Model
is forced to be sequential this can't happen because Model(T) won't
exist in the suite until Model(T-6) has finished. But if Model(T-6)
fails, it can be spawned-and-removed from the suite so that Model(T) can
{\em then} trigger off Model(T-12), which is the correct behaviour.} 

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[one-off]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ one-off}

One-off tasks do not spawn a successor; they run once and are then
removed from the suite when they are no longer needed. {\em Start-up}
and {\em cold-start} tasks are automatically one-off tasks and do not
need to be listed here.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\paragraph[explicit restart outputs]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ explicit restart outputs}

% TO DO: THESE TASKS COULD BE IDENTIFIED FROM THE GRAPH?

This is only required in the event that you need a warm cycled forecast
model to start at the instant its restart files are ready (if other
prerequisites are satisfied) {\em even if its previous instance has
not finished yet}.  If so, the model task has to depend on special
output messages emitted by the previous instance as soon as its restart
files are ready, instead of just on the previous instance finishing.
{\em Tasks in this category must define special restart
output messages containing the word ``restart''}, in
[runtime] $\rightarrow$ [[TASK]] $\rightarrow$ [[[outputs]]] - see
Section~\ref{RIOC}.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[exclude at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ exclude at start-up}

Any task listed here will be excluded from the initial task pool (this
goes for suite restarts too). If an {\em inclusion} list is also
specified, the initial pool will contain only included tasks that have
not been excluded. Excluded tasks can still be inserted at run time.
Other tasks may still depend on excluded tasks if they have not been
removed from the suite dependency graph, in which case some manual
triggering, or insertion of excluded tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\paragraph[include at start-up]{[scheduling] $\rightarrow$ [[special tasks]] $\rightarrow$ include at start-up}

If this list is not empty, any task {\em not} listed in it will be
excluded from the initial task pool (this goes for suite restarts too).
If an {\em exclusion} list is also specified, the initial pool will
contain only included tasks that have not been excluded. Excluded tasks
can still be inserted at run time. Other tasks may still depend on
excluded tasks if they have not been removed from the suite dependency
graph, in which case some manual triggering, or insertion of excluded 
tasks, may be required.

\begin{myitemize}
    \item {\em type:} list of task names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[{[[}dependencies{]]}]{[scheduling] $\rightarrow$ [[dependencies]]}

The suite dependency graph is defined under this section.  You can plot
the dependency graph as you work on it, with \lstinline=cylc graph= or
by right clicking on the suite in gcylc.  See also 
Section~\ref{DependencyGraphs}.

\paragraph[graph]{ [scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ graph }

The dependency graph for any one-off asynchronous (non-cycling) tasks in
the suite goes here. This can be used to construct a suite of one-off
tasks (e.g.\ build jobs and related processing) that just completes and
then exits, or an initial suite section that completes prior to the
cycling tasks starting (if you make the first cycling tasks depend on
the last one-off ones). But note that synchronous {\em start-up} tasks
can also be used for the latter purpose.  See Section~\ref{GraphDescrip}
below for graph string syntax, and Section~\ref{DependencyGraphs}.
\begin{myitemize}
    \item {\em type:} string 
    \item {\em example:} (see Section~\ref{GraphDescrip} below)
\end{myitemize}
 
\paragraph[{[[[}\_\_VALIDITY\_\_{]]]}]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]]}

Replace VALIDITY with a comma-separated list of integer hours, $0\leq
H \leq 23$,  defining the valid
cycle times for the subsequent graph of cycling tasks, or multiple such
subsections as required for different dependencies at different hours; 
or with `ASYNCID:{\em pattern}', where {\em pattern} is a regular
expression that matches an asynchronous task ID, for each graph of
repeating asynchronous tasks.

\begin{myitemize}
    \item {\em examples:} 
        \begin{myitemize} 
            \item (cycling tasks) \lstinline@[[0,6,12,18]]@ 
            \item (repeating asynchronous tasks) \lstinline@[[ASYNCID:SAT-\d+]]@ 
        \end{myitemize}
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[graph]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ graph }
\label{GraphDescrip}

The dependency graph for the specified validity section (described just
above) goes here. Syntax examples follow; see also
Section~\ref{DependencyGraphs}. 

\begin{myitemize}
\item {\em type:} string 
\item {\em example:}
  \begin{lstlisting}
graph = """
   foo => bar => baz & waz   # baz and waz both trigger off bar
   baz:out1 => faz           # faz triggers off an internal output of baz
   ColdFoo | foo(T-6) => foo # cold-start or restart for foo
   X:fail => Y               # Y triggers if X fails
   X => !Y                   # Y suicides if X succeeds
   X | X:fail => Z           # Z triggers if X finishes or fails
   (A | B & C ) | D => foo   # general conditional triggers
   # comment
   # A python expression to generate dependencies automatically:
   Python:list( "m" + str(i) + '=>' + "p" + str(i) for i in range(1,7))
   """
  \end{lstlisting}
\item {\em default:} (none)
\end{myitemize}

\subparagraph[daemon]{[scheduling] $\rightarrow$ [[dependencies]] $\rightarrow$ [[[\_\_VALIDITY\_\_]]] $\rightarrow$ daemon }

For [[[ASYNCID:pattern]]] validity sections only, list 
{\em asynchronous daemon} tasks by name. This item is located here rather than
under [scheduling] $\rightarrow$ [[special tasks]] because a damon task
is associated with a particular asynchronous ID.

\begin{myitemize}
\item {\em type:} list of task names
\item {\em default:} (none)
\end{myitemize}

\subsection{[runtime]}

This section defines how, where, and what to execute when tasks are
ready to run. Runtime subsections define an inheritance hierarchy of 
{\em namespaces}, each of which represents a family of tasks or an
individual task, as described in Section~\ref{NIORP}).

\subsubsection[{[[}\_\_NAME\_\_{]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]]}

Replace \_\_NAME\_\_ with a namespace name, or a comma separated list of
names, or a Python expression that generates a list of names; and repeat
as needed to define all tasks in the suite.

Namespace names may contain letters, digits, underscores, and hyphens.
They may not contain colons (which would preclude use of directory paths
involving the registration name in \lstinline=$PATH= variables). They 
may not contain the `.' character (it will be interpreted 
as the namespace hierarchy delimiter, separating groups and names). 
{\em Task names should not be hardwired into task implementations.}
Rather, task and suite identity should be extracted portably from the
task execution environment supplied by cylc 
(Section~\ref{TaskExecutionEnvironment}) - then to rename a task you
can just change its name in the suite.rc file.


A namespace represents a family if other namespaces inherit from it; it
represents a task if it is a leaf on the inheritance tree (i.e.\ no
other namespaces inherit from it).

\begin{myitemize}
\item {\em legal values:} 
    \begin{myitemize}
        \item \lstinline=[[foo]]=
        \item \lstinline=[[foo, bar, baz]]=
        \item \lstinline=[['Python:list( "m" + str(i) for i in range(0,25))']]=
    \end{myitemize}
\end{myitemize}

If multiple names are listed, the subsequent namespace configuration
items apply to each member, but any instance of \lstinline=$(TASK)= 
in any value will be replaced by cylc with the actual namespace name.
This can be used to define many tasks that are almost identical.

All namespaces inherit initially from {\em root}, which you can
explicitly configure to override or provide default runtime settings for
all tasks in the suite.

\paragraph[inherit]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ inherit}

Specify here the namepace from which this namespace should inherit all
of its runtime configuration; specific items can then be overridden
as required. Note that many of the available items are left undefined even
in the root namespace.

\begin{myitemize}
\item {\em type:} string (another namespace name)
\item {\em default:} root
\end{myitemize}

\paragraph[description]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ description}

A description of this namespace, retrievable from running tasks via 
\lstinline=cylc show=.
\begin{myitemize}
\item {\em type:} string 
\item {\em root default:} ``No description provided''
\end{myitemize}

\paragraph[command scripting]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ command scripting}

The scripting to execute when the associated task is ready to run. The
value can be a single command, or a multiline string of scripting, or a
list of commands or multiline strings. If a list is provided the task
will automatically resubmit with the second list member if the task
fails, and then the third if the task fails again, and so on until no
command scripting list members remain - this is one of the ways you can
do automated failure recovery in cylc. 

\begin{myitemize}
\item {\em type:} (a list of) strings (each )
\item {\em root default:} \lstinline=echo DUMMY $CYLC_TASK_ID; sleep 10; echo BYE=
\end{myitemize}

\paragraph[pre-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ pre-command scripting}

Scripting to be executed immediately {\em before} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em post-command scripting},
below.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\item {\em example:} 
 \begin{lstlisting}
    pre-command scripting = """
      . $HOME/.profile
      echo Hello from suite ${CYLC_SUITE_REG_NAME}!"""
 \end{lstlisting}
\end{myitemize}

\paragraph[post-command scripting]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ post-command scripting}

Scripting to be executed immediately {\em after} the command scripting.
This would typically be used to add scripting to every task in a family
(for individual tasks you could just incorporate the extra commands into
the main command scripting). See also {\em pre-command scripting},
above.

\begin{myitemize}
\item {\em type:} string, or a list of strings
\item {\em default:} (none)
\end{myitemize}

\paragraph[manual completion]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ manual completion}

If a task's initiating process detaches and exits before task processing
is finished then cylc cannot arrange for the task to automatically
signal when it has succeeded or failed. In such cases you must use this 
configuration item to tell cylc not to arrange for automatic completion
messaging, and insert some minimal completion messaging yourself in
appropriate places in the task implementation (see
Section~\ref{DetachingTasks}).

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

% HIDDEN \paragraph[hours]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ hours}

% HIDDEN \paragraph[extra log files]{ [runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ extra log files}

\paragraph[{[[[}job submission{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]]}

This is where to configure the means by which cylc submits task job
scripts to run.

\subparagraph[method]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ method}
\label{RuntimeJobSubMethods}

Cylc currently has a handful of defined job submission methods.
{\em Task Job Submission} (Section~\ref{TaskJobSubmission}) 
explains how job submission works, and how to define new methods.

\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} 
   \begin{myitemize}
       \item \lstinline=background= - direct background execution
       \item \lstinline=at_now= - the rudimentary Unix `at' scheduler
       \item \lstinline=loadleveler= - loadleveler, generic (with
 directives defined in the suite.rc file) 
       \item \lstinline=ll_ecox= - loadleveler, customized for
                    EcoConnect triplicate environment at NIWA
       \item \lstinline=ll_raw= - loadleveler, for existing job scripts
   \end{myitemize}
\item {\em default:} \lstinline=background=
\end{myitemize}

\subparagraph[command template]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ command template}

This allows you to override the actual command used by the chosen job
submission method. The template's first \%s will be substituted by the
job file path.  Where applicable the second and third \%s will be
substituted by the paths to the stdout and stderr files.

\begin{myitemize}
\item {\em type:} string
\item {\em legal values:} a string template
\item {\em example:} \lstinline@llsubmit %s@
\end{myitemize}

\subparagraph[shell]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ shell}
\label{JobSubShell}

This is the shell used to interpret the job script submitted by cylc
when a task is ready to run.  {\em It has no bearing on the shell used
in task implementations.} Command scripting and suite environment 
variable assignment expressions must be valid for this shell. The 
latter is currently hardwired into cylc as 
\lstinline@export item=value@ - valid for both bash and ksh
because \lstinline=value= is entirely user-defined - but cylc would have
to be modified slightly to allow use of the C shell.

\begin{myitemize}
\item {\em type:} string
\item {\em root default:} \lstinline=/bin/bash= 
\end{myitemize}

\subparagraph[log directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[job submission]]] $\rightarrow$ log directory}
\label{LocalLog}

This is where task job scripts, and the stdout and stderr logs for local
tasks, are written. The directory path may contain environment
variables, including suite identity variables to make the path
suite-specific (as the default value does).
%? Remote tasks must also define a [[[remote]]] log directory. 
%? For owned tasks, the suite owner's home directory is replaced by the
%? task owner's.
The job script filename is constructed, just before job submission,
from the task ID and {\em seconds since epoch}, and then {\em .out} and
{\em .err} are appended to construct the stdout and stderr log names,
respectively. These filenames are thus unique even if a task
gets retriggered, and yet will be correctly time ordered if the log
directory is listed. The filenames are also recorded by each task proxy 
for access via cylc commands and the suite control GUIs.

\begin{myitemize}
\item {\em type:} string (directory path, may contain environment variables)
\item {\em default:} \lstinline=$HOME/cylc-run/$CYLC_SUITE_REG_NAME/log/job=
\end{myitemize}

\paragraph[{[[[}remote{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]]}

Remote hosting configuration, for tasks that need to run on platforms
other than the suite host. If a remote host is specified cylc
will attempt to execute the task on that host by passwordless ssh.
Relevant task scripts and executables, cylc itself, and possibly all or
part of the suite definition directory, must be installed on the remote
host. Passwordless ssh must be configured between the local suite owner
and remote task owner accounts.

\subparagraph[host]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ host}

The remote host for this task or family.

\begin{myitemize}
\item {\em type:} string (a valid hostname on the network)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[owner]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ owner}

User name under which to access the remote host, via passwordless ssh. 

\begin{myitemize}
\item {\em type:} string (a valid username on the remote host)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[cylc directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ cylc directory}

The path to the cylc installation on the remote host (this is a required
item for tasks that define a remote host).

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (none)
\end{myitemize}

\subparagraph[suite definition directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$  suite definition directory}

The path to the suite definition directory on the remote host, needed if
remote tasks require access to files stored there (via
\lstinline=$CYLC_SUITE_DEF_PATH=) or in the suite bin directory (via
\lstinline=$PATH=).  If this item is not defined, the local suite
definition directory path will be assumed, with the suite owner's home
directory (if present) replaced by \lstinline='$HOME'= (for
interpretation on the remote host). 

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (local suite definition path with \lstinline=$HOME= replaced)
\end{myitemize}
 
\subparagraph[remote shell template]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ remote shell template }

A template for the remote shell command for a submitting a remote task.
The template's first \%s will be substituted by the remote user@host.

\begin{myitemize}
\item {\em type:} string (a string template)
\item {\em root default:} \lstinline@ssh -oBatchMode=yes %s@
\end{myitemize}

\subparagraph[log directory]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[remote]]] $\rightarrow$ log directory }

This log directory is used for the stdout and stderr logs of remote
tasks. The directory will be created on the fly if necessary. If not
specified, the local log path will be used (see~\ref{LocalLog}) with the
suite owner's home directory path (if present) replaced by
\lstinline='$HOME'= (for interpretation on the remote host).  The stdout
and stderr log file names are the same as for local tasks, and are
recorded for access via gcylc. You could use an event hook script to
automatically retrieve remote log files on task completion to make them
available as for local task logs.

\begin{myitemize}
\item {\em type:} string (a valid directory path on the remote host)
\item {\em default:} (local log path with \lstinline=$HOME= replaced)
\end{myitemize}
 
\paragraph[{[[[}event hooks{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]]}

Cylc can call a nominated script when certain events, such as task
failure or timeout, occur.  This is intended to facilitate centralized
alerting and automated handling of critical events. Event hook scripts
can do anything you like, such as send emails or SMS, call pagers, or
intervene in the operation of their parent suite with cylc
commands. The utility command \lstinline=cylc [util] email-alert= 
is a ready made event hook script.

Currently a single script can be nominated to handle a list of chosen
events, and the event name is passed on the command line to allow the 
script to distinguish between events (we originally allowed distinct
hook scripts for each event, but this required rather verbose
configuration for little gain).

Event hook scripts can be located in the suite bin directory.  They are
passed the following arguments by cylc:

\begin{lstlisting}
<hook-script> EVENT SUITE TASKID MESSAGE
\end{lstlisting}
where EVENT is one of the following strings:
\begin{myitemize}
    \item `submitted' - the task was submitted
    \item `started' - the task started running 
    \item `succeeded' - the task succeeded
    \item `submission\_failed' - the task failed in job submission
    \item `failed' - the task failed
    \item `timeout' - the task timed out
\end{myitemize}
MESSAGE, if provided, describes what has happened, and TASKID identifies
the offending  task (e.g.\ \lstinline=TASK%CYCLE= for cycling tasks).

{\em Note that event hook scripts are called by cylc itself, not by the 
running tasks} so if you wish to pass in additional information via the
environment, use [cylc] $\rightarrow$ [[environment]] not the
runtime namespace environments.

\subparagraph[events]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ events }

The list of events to handle, as listed for EVENT just above.
\begin{myitemize}
    \item {\em type:} list of strings
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[script]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ script}

The script to call when one of the nominated events occurs.

\begin{myitemize}
    \item {\em type:} string
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[submission timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ submission timeout}

If a task has not started the specified number of minutes after it was
submitted, the hook script will be called by cylc with `timeout' as 
the EVENT argument:
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[execution timeout]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ execution timeout}

If a task has not finished the specified number of minutes after it
started running, the hook script will be called by cylc with `timeout'
as the EVENT argument:
\begin{myitemize}
    \item {\em type:} float (minutes)
    \item {\em default:} (none)
\end{myitemize}

\subparagraph[reset timer]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[event hooks]]] $\rightarrow$ reset timer}

If you set an execution timeout the timer can be reset to zero every
time a message is received from the running task (which indicates the 
task is still alive) .  Otherwise, the task will timeout if it does not
finish in the alotted time regardless of incoming messages.

\begin{myitemize}
\item {\em type:} boolean
\item {\em default:} False
\end{myitemize}

\paragraph[{[[[}environment{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[environment]]]}

The user defined execution environment. Variables defined here can refer 
to cylc suite and task identity variables, which are exported earlier in 
the task job script, and variable assignment expressions can use cylc
utility commands because access to cylc is also configured earlier in
the script.  See also {\em Task Execution Environment},
Section~\ref{TaskExecutionEnvironment}.

\subparagraph[\_\_VARIABLE\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_VARIABLE\_\_}

Replace \_\_VARIABLE\_\_ with an environment variable assignment
expression, which must be valid in the job submission shell, and repeat
for as many environment variables as you need. Order of definition is
preserved, so values can refer to previously defined variables.

\begin{myitemize}
\item {\em type:} string (any environment variable assignment
 expression valid in the job submission shell)

\item {\em default:} (none)
\item {\em legal values:}  (Section~\ref{JobSubShell}). White space
    around the `$=$' is allowed (the \lstinline=suite.rc= file is not a
    shell script). 
 \item {\em examples} for the bash shell: 
   \begin{myitemize}
       \item \lstinline@FOO = $HOME/bar/baz@
       \item \lstinline@BAR = ${FOO}$GLOBALVAR@
       \item \lstinline@BAZ = $(echo "hello world")@
       \item \lstinline@WAZ = ${FOO%.jpg}.png@
       \item \lstinline@NEXT_CYCLE = $( cylc cycletime -a 6 )@
       \item \lstinline@PREV_CYCLE = `cylc cycletime -s 6`@
       \item \lstinline@ZAZ = "${FOO#bar}" # <-- QUOTED to escape the suite.rc comment character@ 
   \end{myitemize}
\end{myitemize}

\paragraph[{[[[}directives{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[directives]]]}

Batch queue scheduler directives, or similar.  Whether or not these are
used depends on the job submission method. For the loadleveler method,
for example, directives are written to the top of the task job script in
the format required by loadleveler.

\subparagraph[\_\_DIRECTIVE\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_DIRECTIVE\_\_}

Replace \_\_DIRECTIVE\_\_ with each directive assignment, e.g. 
\lstinline@class = parallel@

\begin{myitemize}
\item {\em type:} string
\item {\em default:} (none)
\end{myitemize}

\paragraph[{[[[}outputs{]]]}]{[runtime] $\rightarrow$ [[\_\_NAME\_\_]] $\rightarrow$ [[[outputs]]]}

This section is only required if other tasks need to trigger off specific
internal outputs of this task (as opposed to triggering off it finishing).
The task implementation must report the specified output messages 
by calling \lstinline=cylc task message= when the
corresponding real outputs have been completed.

\subparagraph[\_\_OUTPUT\_\_ ]{[cylc] $\rightarrow$ [[environment]] $\rightarrow$ \_\_OUTPUT\_\_}

Replace \_\_OUTPUT\_\_ with any number of labelled output messages. 
\begin{myitemize}
    \item {\em type:} string (a message containing
        \lstinline=$(CYCLE_TIME)= with an optional offset as shown
        below. Note the round parentheses on \lstinline=$(CYCLE_TIME)= -
        this is not a shell variable, although without an
        offset it does correspond to \lstinline=$CYLC_TASK_CYCLE_TIME= 
        in the task execution environment.
\item {\em default:} (none)
\item{ \em examples:}
 \begin{lstlisting}
 foo = "sea state products ready for $(CYCLE_TIME)"
 bar = "nwp restart files ready for $(CYCLE_TIME+6)"
 \end{lstlisting}
 where the item name must match the output label associated with
 this task in the suite dependency graph, e.g.:
\lstset{language=suiterc}
\begin{lstlisting}
[scheduling]
    [dependencies]
        graph = TaskA:foo => TaskB
 \end{lstlisting}
\end{myitemize}
\lstset{language=transcript}

\subsection{[visualization]}

Configuration of suite graphing and, where explicitly stated, the
graph-based suite control GUI.

\subsubsection[initial cycle time]{[visualization] $\rightarrow$ initial cycle time}

The first cycle time to use when plotting the suite dependency graph.
\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 2999010100
\end{myitemize}

\subsubsection[final cycle time]{[visualization] $\rightarrow$ final cycle time}

The last cycle time to use when plotting the suite dependency graph.
Typically this should be just far enough ahead of the initial cycle to
show the full suite.

\begin{myitemize}
    \item {\em type:} integer
    \item {\em default:} 2999010123
\end{myitemize}

\subsubsection[collapsed families]{[visualization] $\rightarrow$ collapsed families}

A list of family names to be shown in the collapsed state (i.e.\ the
family members will be replaced by a single family node). This can be
changed in real time while viewing the suite graph. For the graph-based
suite control GUI this item only affects the initial graph layout, after
which you can expand and collapse family nodes at will via menu options.

\begin{myitemize}
    \item {\em type:} list of family names
    \item {\em default:} (none)
\end{myitemize}

\subsubsection[use node color for edges]{[visualization] $\rightarrow$ use node color for edges}

Graph edges (dependency arrows) can be plotted in the same color
as the upstream node (task or family) to make paths through a complex
graph easier to follow.

\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} True
\end{myitemize}

\subsubsection[default node attributes]{[visualization] $\rightarrow$ default node attributes}

Set the default attributes (color and style etc.) of graph nodes (tasks and families).
Attribute pairs must be quoted to hide the internal \lstinline@=@ character.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'style=unfilled', 'color=black', 'shape=box'@
\end{myitemize}

\subsubsection[default edge attributes]{[visualization] $\rightarrow$ default edge attributes}

Set the default attributes (color and style etc.) of graph edges
(dependency arrows).  Attribute pairs must be quoted to hide the
internal \lstinline@=@ character.
\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} \lstinline@'color=black'@
\end{myitemize}

\subsubsection[{[[}node groups{]]}]{[visualization] $\rightarrow$ [[node groups]]}

Define named groups of graph nodes (tasks and families) that can have
attributes assigned to them en masse in the 
[visualization] $\rightarrow$ [[node attributes]] section.

\paragraph[\_\_GROUP\_\_]{[visualization] $\rightarrow$ [[node groups]] $\rightarrow$ \_\_GROUP\_\_}

Replace \_\_GROUP\_\_ with each named group of task or family names.

\begin{myitemize}
    \item {\em type:} comma separated list of task or family names
    \item {\em default:} (none)
    \item {\em example:}
\begin{lstlisting}
   PreProc = foo, bar
   PostProc = baz, waz
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}node attributes{]]}]{[visualization] $\rightarrow$ [[node attributes]]}

Here you can assign graph node attributes to specific tasks, or named
groups defined in [visualization] $\rightarrow$ [[node groups]].

\paragraph[\_\_NAME\_\_]{[visualization] $\rightarrow$ [[node attributes]] $\rightarrow$ \_\_NAME\_\_}

Replace \_\_NAME\_\_ with any task, family, or group that you want to
assign attributes to.

\begin{myitemize}
    \item {\em type:} list of quoted \lstinline@'attribute=value'@ pairs
    \item {\em legal values:} see graphviz or pygraphviz documentation
    \item {\em default:} (none)
    \item {\em example:} (with reference to the node groups defined above)
\begin{lstlisting}
   PreProc = 'style=filled', 'color=blue'
   PostProc = 'color=red'
   foo = 'style=unfilled'
\end{lstlisting}
\end{myitemize}

\subsubsection[{[[}run time graph{]]}]{[visualization] $\rightarrow$ [[run time graph]]}

Cylc can generate graphs of dependencies resolved at run time, i.e.\ what 
actually triggers off what as the suite runs. This feature is retained
mainly for development and debugging purposes. You can use simulation
mode to generate run time graphs very quickly.

\paragraph[enable]{[visualization] $\rightarrow$ [[run time graph]] $\rightarrow$ enable}

Run time graphing is now disabled by default.
\begin{myitemize}
    \item {\em type:} boolean
    \item {\em default:} False
\end{myitemize}

\paragraph[cutoff]{[visualization] $\rightarrow$ [[run time graph]] $\rightarrow$ cutoff}

New nodes will be added to the run time graph as the corresponding tasks
trigger, until their cycle time exceeds the initial cycle time by more
than this cutoff, in hours.

\begin{myitemize}
    \item {\em type:} integer ($\geq 0$, hours)
    \item {\em default:} $24$
\end{myitemize}

\paragraph[directory]{[visualization] $\rightarrow$ [[run time graph]] $\rightarrow$ directory}

Where to put the run time graph file, \lstinline=runtime-graph.dot=.

\begin{myitemize}
    \item {\em type:} string (a valid directory path, may contain environment variables)
    \item {\em default:} \lstinline=$CYLC_SUITE_DEF_PATH/graphing=
\end{myitemize}

% HIDDEN \subsection{[development]}
% HIDDEN \subsubsection[use quick task elimination]{[development] $\rightarrow$ use quick task elimination }
% HIDDEN     default True
% HIDDEN \subsubsection[live graph movie]{[development] $\rightarrow$ live graph movie}
% HIDDEN     default False


\subsection{Default Suite Configuration}
\label{SuiteDefaults}

Cylc provides, via the suite.rc spec file, sensible default values for
many configuration items so that users may not need to explicitly
configure log directories and the like. The defaults are sufficient, in
fact, to define simple test suites by dependency graph alone
(command scripting, for example, defaults to printing a
simple message, sleeping for ten seconds, and then exiting). The
following listing shows all current legal items and any default values:

\lstset{language=suiterc}
\lstinputlisting{../conf/suite.rc}
\lstset{language=transcript}
